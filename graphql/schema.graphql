"A datetime string with format 'Y-m-d H:i:s', e.g. '2018-05-23 13:43:32'."
scalar DateTime @scalar(class: "Nuwave\\Lighthouse\\Schema\\Types\\Scalars\\DateTime")

"A date string with format 'Y-m-d', e.g. '2011-05-23'."
scalar Date @scalar(class: "Nuwave\\Lighthouse\\Schema\\Types\\Scalars\\Date")

type Query {
    customers(
        first_name: String @where(operator: "like")
        last_name: String @where(operator: "like")
        identity_document: String @where(operator: "like")
        email_address: String @where(operator: "like")
        customer_status: String @eq
        search: String @scope(name: "search")
    ): [Customer!]! @paginate(defaultCount: 10, model: "App\\Models\\Customers\\Customer")
    customer(id: ID! @eq): Customer @find(model: "App\\Models\\Customers\\Customer")

    services(
        service_ip: String @where(operator: "like")
        service_status: String @eq
        customer_id: ID @eq
        mac_address: String @where(operator: "like")
        service_type: String @eq
    ): [Service!]! @paginate(defaultCount: 10, model: "App\\Models\\Services\\Service")
    service(id: ID! @eq): Service @find(model: "App\\Models\\Services\\Service")

    invoices(
        increment_id: String @where(operator: "like")
        status: String @eq
        customer_id: ID @eq
    ): [Invoice!]! @paginate(defaultCount: 10, model: "App\\Models\\Invoice\\Invoice")
    invoice(id: ID! @eq): Invoice @find(model: "App\\Models\\Invoice\\Invoice")

    billingNovedades: [BillingNovedad!]! @paginate(defaultCount: 10, model: "App\\Models\\BillingNovedad")
    creditNotes: [CreditNote!]! @paginate(defaultCount: 10, model: "App\\Models\\Invoice\\CreditNote")
    paymentPromises: [PaymentPromise!]! @paginate(defaultCount: 10, model: "App\\Models\\Invoice\\PaymentPromise")

    routers: [Router!]! @paginate(defaultCount: 10, model: "App\\Models\\Router")
    router(id: ID! @eq): Router @find(model: "App\\Models\\Router")

    plans: [Plan!]! @paginate(defaultCount: 10, model: "App\\Models\\Services\\Plan")
    plan(id: ID! @eq): Plan @find(model: "App\\Models\\Services\\Plan")
}

type Mutation {
    createCustomer(
        first_name: String! @rules(apply: ["required", "max:255"])
        last_name: String! @rules(apply: ["required", "max:255"])
        email_address: String @rules(apply: ["email", "max:255"])
        phone_number: String
        identity_document: String @rules(apply: ["required", "unique:customers,identity_document"])
        document_type: String! @rules(apply: ["required", "max:50"])
        router_id: Int @rules(apply: ["exists:routers,id"])
    ): Customer @create(model: "App\\Models\\Customers\\Customer")

    updateCustomer(
        id: ID! @rules(apply: ["required", "exists:customers,id"])
        first_name: String
        last_name: String
        email_address: String @rules(apply: ["email"])
        phone_number: String
        document_type: String
        router_id: Int @rules(apply: ["exists:routers,id"])
    ): Customer @update(model: "App\\Models\\Customers\\Customer")

    deleteCustomer(
        id: ID! @rules(apply: ["required", "exists:customers,id"])
    ): Customer @delete(model: "App\\Models\\Customers\\Customer")

    createAddress(
        customer_id: Int! @rules(apply: ["required", "exists:customers,id"])
        address: String! @rules(apply: ["required", "max:255"])
        city: String
        state_province: String
        postal_code: String
        country: String
        address_type: String
    ): Address @create(model: "App\\Models\\Customers\\Address")

    updateAddress(
        id: ID! @rules(apply: ["required", "exists:addresses,id"])
        address: String
        city: String
        state_province: String
        postal_code: String
        country: String
        address_type: String
    ): Address @update(model: "App\\Models\\Customers\\Address")

    deleteAddress(
        id: ID! @rules(apply: ["required", "exists:addresses,id"])
    ): Address @delete(model: "App\\Models\\Customers\\Address")

    createService(
        customer_id: Int! @rules(apply: ["required", "exists:customers,id"])
        plan_id: Int! @rules(apply: ["required", "exists:plans,id"])
        router_id: Int! @rules(apply: ["required", "exists:routers,id"])
        service_ip: String! @rules(apply: ["required", "ip"])
        service_location: Int! @rules(apply: ["required", "exists:addresses,id"])
        service_status: String @rules(apply: ["in:active,inactive,suspended,pending,free"])
        username_router: String
        password_router: String
        activation_date: DateTime
        deactivation_date: DateTime
        bandwidth: Int
        mac_address: String
        installation_date: DateTime
        service_notes: String
        support_contact: String
        service_type: String @rules(apply: ["in:ftth,adsl,satellite"])
        static_ip: Boolean
        data_limit: Int
        last_maintenance: Date
        billing_cycle: String
        service_priority: String @rules(apply: ["in:normal,high,critical"])
        sn: String
        unu_longitude: String
        unu_latitude: String
        assigned_technician: Int
        service_contract: String
    ): Service @create(model: "App\\Models\\Services\\Service")

    updateService(
        id: ID! @rules(apply: ["required", "exists:services,id"])
        service_ip: String @rules(apply: ["ip"])
        service_location: Int @rules(apply: ["exists:addresses,id"])
        service_status: String @rules(apply: ["in:active,inactive,suspended,pending,free"])
        plan_id: Int @rules(apply: ["exists:plans,id"])
        router_id: Int @rules(apply: ["exists:routers,id"])
        username_router: String
        password_router: String
        activation_date: DateTime
        deactivation_date: DateTime
        bandwidth: Int
        mac_address: String
        installation_date: DateTime
        service_notes: String
        support_contact: String
        service_type: String @rules(apply: ["in:ftth,adsl,satellite"])
        static_ip: Boolean
        data_limit: Int
        last_maintenance: Date
        billing_cycle: String
        service_priority: String @rules(apply: ["in:normal,high,critical"])
        sn: String
        unu_longitude: String
        unu_latitude: String
        assigned_technician: Int
        service_contract: String
    ): Service @update(model: "App\\Models\\Services\\Service")

    createRouter(
        name: String! @rules(apply: ["required", "max:255"])
        ip_address: String! @rules(apply: ["required", "ip"])
        description: String
    ): Router @create(model: "App\\Models\\Router")

    updateRouter(
        id: ID! @rules(apply: ["required", "exists:routers,id"])
        name: String
        ip_address: String @rules(apply: ["ip"])
        description: String
    ): Router @update(model: "App\\Models\\Router")

    createPlan(
        name: String! @rules(apply: ["required", "max:255"])
        monthly_price: Float! @rules(apply: ["required", "numeric", "min:0"])
        status: String! @rules(apply: ["required", "in:active,inactive"])
        download_speed: Int! @rules(apply: ["required", "integer", "min:0"])
        upload_speed: Int! @rules(apply: ["required", "integer", "min:0"])
        description: String
        overage_fee: Float
        data_limit: Int
        unlimited_data: Boolean
        contract_period: String
        promotions: String
        extras_included: String
        geographic_availability: String
        promotion_start_date: DateTime
        promotion_end_date: DateTime
        plan_image: String
        customer_rating: Float
        customer_reviews: String
        service_compatibility: String
        network_priority: String
        profile_smart_olt: String
        technical_support: String
        additional_benefits: String
        connection_type: String
        plan_type: String @rules(apply: ["in:internet,television,telephonic"])
        modality_type: String @rules(apply: ["in:prepaid,postpaid"])
    ): Plan @create(model: "App\\Models\\Services\\Plan")

    updatePlan(
        id: ID! @rules(apply: ["required", "exists:plans,id"])
        name: String
        monthly_price: Float @rules(apply: ["numeric", "min:0"])
        status: String @rules(apply: ["in:active,inactive"])
        description: String
        download_speed: Int
        upload_speed: Int
        overage_fee: Float
        data_limit: Int
        unlimited_data: Boolean
        contract_period: String
        promotions: String
        extras_included: String
        geographic_availability: String
        promotion_start_date: DateTime
        promotion_end_date: DateTime
        plan_image: String
        customer_rating: Float
        customer_reviews: String
        service_compatibility: String
        network_priority: String
        profile_smart_olt: String
        technical_support: String
        additional_benefits: String
        connection_type: String
        plan_type: String @rules(apply: ["in:internet,television,telephonic"])
        modality_type: String @rules(apply: ["in:prepaid,postpaid"])
    ): Plan @update(model: "App\\Models\\Services\\Plan")

    deletePlan(
        id: ID! @rules(apply: ["required", "exists:plans,id"])
    ): Plan @delete(model: "App\\Models\\Services\\Plan")
}

type Customer {
    id: ID!
    first_name: String!
    last_name: String!
    email_address: String
    phone_number: String
    identity_document: String
    document_type: String!
    customer_status: String
    router_id: Int
    created_at: DateTime!
    updated_at: DateTime!

    addresses: [Address!]! @hasMany
    services: [Service!]! @hasMany
    invoices: [Invoice!]! @hasMany
    router: Router @belongsTo
}

type Address {
    id: ID!
    address: String!
    city: String
    state_province: String
    postal_code: String
    country: String
    address_type: String
    created_at: DateTime!
    updated_at: DateTime!
    
    customer: Customer! @belongsTo
}

type Service {
    id: ID!
    router_id: Int!
    customer_id: Int!
    plan_id: Int!
    service_ip: String!
    username_router: String
    password_router: String
    service_status: String
    activation_date: DateTime
    deactivation_date: DateTime
    bandwidth: Int
    mac_address: String
    installation_date: DateTime
    service_notes: String
    contract_id: Int
    support_contact: String
    service_location: Int!
    service_type: String
    static_ip: Boolean
    data_limit: Int
    last_maintenance: Date
    billing_cycle: String
    service_priority: String
    sn: String
    unu_longitude: String
    unu_latitude: String
    assigned_technician: Int
    service_contract: String
    created_by: Int
    updated_by: Int
    created_at: DateTime!
    updated_at: DateTime!

    customer: Customer! @belongsTo
    invoices: [Invoice!]! @hasMany
    plan: Plan! @belongsTo
    router: Router! @belongsTo
    address: Address @belongsTo(relation: "address")
}

type Invoice {
    id: ID!
    increment_id: String
    total: Float!
    status: String!
    issue_date: Date
    due_date: Date
    router_id: Int
    created_at: DateTime!
    updated_at: DateTime!

    customer: Customer! @belongsTo
    service: Service @belongsTo
    items: [InvoiceItem!]! @hasMany
    adjustments: [InvoiceAdjustment!]! @hasMany
    creditNotes: [CreditNote!]! @hasMany
    paymentPromises: [PaymentPromise!]! @hasMany
    router: Router @belongsTo
}

type Plan {
    id: ID!
    name: String!
    description: String
    is_synchronized: Boolean
    download_speed: Int!
    upload_speed: Int!
    monthly_price: Float!
    overage_fee: Float
    data_limit: Int
    unlimited_data: Boolean
    contract_period: String
    promotions: String
    extras_included: String
    geographic_availability: String
    promotion_start_date: DateTime
    promotion_end_date: DateTime
    plan_image: String
    customer_rating: Float
    customer_reviews: String
    service_compatibility: String
    network_priority: String
    profile_smart_olt: String
    technical_support: String
    additional_benefits: String
    connection_type: String
    status: String!
    plan_type: String
    modality_type: String
    created_by: Int
    updated_by: Int
    created_at: DateTime!
    updated_at: DateTime!

    services: [Service!]! @hasMany
}

type InvoiceItem {
    id: ID!
    description: String
    quantity: Int
    unit_price: Float
    subtotal: Float
    created_at: DateTime!
    updated_at: DateTime!
    
    invoice: Invoice! @belongsTo
    service: Service @belongsTo
}

type BillingNovedad {
    id: ID!
    type: String!
    amount: Float!
    description: String
    applied: Boolean!
    effective_period: Date
    created_at: DateTime!
    updated_at: DateTime!
    
    service: Service @belongsTo
    customer: Customer @belongsTo
    invoice: Invoice @belongsTo
}

type InvoiceAdjustment {
    id: ID!
    kind: String!
    amount: Float!
    label: String
    created_at: DateTime!
    updated_at: DateTime!
    
    invoice: Invoice! @belongsTo
}

type CreditNote {
    id: ID!
    amount: Float!
    issue_date: Date
    reason: String
    created_at: DateTime!
    updated_at: DateTime!
    
    invoice: Invoice! @belongsTo
}

type PaymentPromise {
    id: ID!
    amount: Float!
    promise_date: Date
    notes: String
    status: String
    created_at: DateTime!
    updated_at: DateTime!

    invoice: Invoice! @belongsTo
    customer: Customer! @belongsTo
}

type Router {
    id: ID!
    name: String!
    ip_address: String!
    description: String
    created_at: DateTime!
    updated_at: DateTime!

    customers: [Customer!]! @hasMany
    services: [Service!]! @hasMany
    invoices: [Invoice!]! @hasMany
}
